{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global['fast-copy'] = factory());\n})(this, function () {\n  'use strict';\n\n  var toStringFunction = Function.prototype.toString;\n  var create = Object.create,\n      defineProperty = Object.defineProperty,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n      getOwnPropertyNames = Object.getOwnPropertyNames,\n      getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      getPrototypeOf = Object.getPrototypeOf;\n  var _a = Object.prototype,\n      hasOwnProperty = _a.hasOwnProperty,\n      propertyIsEnumerable = _a.propertyIsEnumerable;\n  /**\r\n   * @enum\r\n   *\r\n   * @const {Object} SUPPORTS\r\n   *\r\n   * @property {boolean} SYMBOL_PROPERTIES are symbol properties supported\r\n   * @property {boolean} WEAKMAP is WeakMap supported\r\n   */\n\n  var SUPPORTS = {\n    SYMBOL_PROPERTIES: typeof getOwnPropertySymbols === 'function',\n    WEAKMAP: typeof WeakMap === 'function'\n  };\n  /**\r\n   * @function createCache\r\n   *\r\n   * @description\r\n   * get a new cache object to prevent circular references\r\n   *\r\n   * @returns the new cache object\r\n   */\n\n  var createCache = function createCache() {\n    if (SUPPORTS.WEAKMAP) {\n      return new WeakMap();\n    } // tiny implementation of WeakMap\n\n\n    var object = create({\n      has: function has(key) {\n        return !!~object._keys.indexOf(key);\n      },\n      set: function set(key, value) {\n        object._keys.push(key);\n\n        object._values.push(value);\n      },\n      get: function get(key) {\n        return object._values[object._keys.indexOf(key)];\n      }\n    });\n    object._keys = [];\n    object._values = [];\n    return object;\n  };\n  /**\r\n   * @function getCleanClone\r\n   *\r\n   * @description\r\n   * get an empty version of the object with the same prototype it has\r\n   *\r\n   * @param object the object to build a clean clone from\r\n   * @param realm the realm the object resides in\r\n   * @returns the empty cloned object\r\n   */\n\n\n  var getCleanClone = function getCleanClone(object, realm) {\n    if (!object.constructor) {\n      return create(null);\n    }\n\n    var Constructor = object.constructor;\n    var prototype = object.__proto__ || getPrototypeOf(object);\n\n    if (Constructor === realm.Object) {\n      return prototype === realm.Object.prototype ? {} : create(prototype);\n    }\n\n    if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n      try {\n        return new Constructor();\n      } catch (_a) {}\n    }\n\n    return create(prototype);\n  };\n  /**\r\n   * @function getObjectCloneLoose\r\n   *\r\n   * @description\r\n   * get a copy of the object based on loose rules, meaning all enumerable keys\r\n   * and symbols are copied, but property descriptors are not considered\r\n   *\r\n   * @param object the object to clone\r\n   * @param realm the realm the object resides in\r\n   * @param handleCopy the function that handles copying the object\r\n   * @returns the copied object\r\n   */\n\n\n  var getObjectCloneLoose = function getObjectCloneLoose(object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n\n    for (var key in object) {\n      if (hasOwnProperty.call(object, key)) {\n        clone[key] = handleCopy(object[key], cache);\n      }\n    }\n\n    if (SUPPORTS.SYMBOL_PROPERTIES) {\n      var symbols = getOwnPropertySymbols(object);\n      var length_1 = symbols.length;\n\n      if (length_1) {\n        for (var index = 0, symbol = void 0; index < length_1; index++) {\n          symbol = symbols[index];\n\n          if (propertyIsEnumerable.call(object, symbol)) {\n            clone[symbol] = handleCopy(object[symbol], cache);\n          }\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\r\n   * @function getObjectCloneStrict\r\n   *\r\n   * @description\r\n   * get a copy of the object based on strict rules, meaning all keys and symbols\r\n   * are copied based on the original property descriptors\r\n   *\r\n   * @param object the object to clone\r\n   * @param realm the realm the object resides in\r\n   * @param handleCopy the function that handles copying the object\r\n   * @returns the copied object\r\n   */\n\n\n  var getObjectCloneStrict = function getObjectCloneStrict(object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n    var properties = SUPPORTS.SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object);\n    var length = properties.length;\n\n    if (length) {\n      for (var index = 0, property = void 0, descriptor = void 0; index < length; index++) {\n        property = properties[index];\n\n        if (property !== 'callee' && property !== 'caller') {\n          descriptor = getOwnPropertyDescriptor(object, property);\n\n          if (descriptor) {\n            // Only clone the value if actually a value, not a getter / setter.\n            if (!descriptor.get && !descriptor.set) {\n              descriptor.value = handleCopy(object[property], cache);\n            }\n\n            try {\n              defineProperty(clone, property, descriptor);\n            } catch (error) {\n              // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n              clone[property] = descriptor.value;\n            }\n          } else {\n            // In extra edge cases where the property descriptor cannot be retrived, fall back to\n            // the loose assignment.\n            clone[property] = handleCopy(object[property], cache);\n          }\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\r\n   * @function getRegExpFlags\r\n   *\r\n   * @description\r\n   * get the flags to apply to the copied regexp\r\n   *\r\n   * @param regExp the regexp to get the flags of\r\n   * @returns the flags for the regexp\r\n   */\n\n\n  var getRegExpFlags = function getRegExpFlags(regExp) {\n    var flags = '';\n\n    if (regExp.global) {\n      flags += 'g';\n    }\n\n    if (regExp.ignoreCase) {\n      flags += 'i';\n    }\n\n    if (regExp.multiline) {\n      flags += 'm';\n    }\n\n    if (regExp.unicode) {\n      flags += 'u';\n    }\n\n    if (regExp.sticky) {\n      flags += 'y';\n    }\n\n    return flags;\n  }; // utils\n\n\n  var isArray = Array.isArray;\n\n  var GLOBAL_THIS = function () {\n    if (typeof self !== 'undefined') {\n      return self;\n    }\n\n    if (typeof window !== 'undefined') {\n      return window;\n    }\n\n    if (typeof global !== 'undefined') {\n      return global;\n    }\n\n    if (console && console.error) {\n      console.error('Unable to locate global object, returning \"this\".');\n    }\n  }();\n  /**\r\n   * @function copy\r\n   *\r\n   * @description\r\n   * copy an object deeply as much as possible\r\n   *\r\n   * If `strict` is applied, then all properties (including non-enumerable ones)\r\n   * are copied with their original property descriptors on both objects and arrays.\r\n   *\r\n   * The object is compared to the global constructors in the `realm` provided,\r\n   * and the native constructor is always used to ensure that extensions of native\r\n   * objects (allows in ES2015+) are maintained.\r\n   *\r\n   * @param object the object to copy\r\n   * @param [options] the options for copying with\r\n   * @param [options.isStrict] should the copy be strict\r\n   * @param [options.realm] the realm (this) object the object is copied from\r\n   * @returns the copied object\r\n   */\n\n\n  function copy(object, options) {\n    // manually coalesced instead of default parameters for performance\n    var isStrict = !!(options && options.isStrict);\n    var realm = options && options.realm || GLOBAL_THIS;\n    var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\n    /**\r\n     * @function handleCopy\r\n     *\r\n     * @description\r\n     * copy the object recursively based on its type\r\n     *\r\n     * @param object the object to copy\r\n     * @returns the copied object\r\n     */\n\n    var handleCopy = function handleCopy(object, cache) {\n      if (!object || typeof object !== 'object') {\n        return object;\n      }\n\n      if (cache.has(object)) {\n        return cache.get(object);\n      }\n\n      var Constructor = object.constructor; // plain objects\n\n      if (Constructor === realm.Object) {\n        return getObjectClone(object, realm, handleCopy, cache);\n      }\n\n      var clone; // arrays\n\n      if (isArray(object)) {\n        // if strict, include non-standard properties\n        if (isStrict) {\n          return getObjectCloneStrict(object, realm, handleCopy, cache);\n        }\n\n        var length_1 = object.length;\n        clone = new Constructor();\n        cache.set(object, clone);\n\n        for (var index = 0; index < length_1; index++) {\n          clone[index] = handleCopy(object[index], cache);\n        }\n\n        return clone;\n      } // dates\n\n\n      if (object instanceof realm.Date) {\n        return new Constructor(object.getTime());\n      } // regexps\n\n\n      if (object instanceof realm.RegExp) {\n        clone = new Constructor(object.source, object.flags || getRegExpFlags(object));\n        clone.lastIndex = object.lastIndex;\n        return clone;\n      } // maps\n\n\n      if (realm.Map && object instanceof realm.Map) {\n        clone = new Constructor();\n        cache.set(object, clone);\n        object.forEach(function (value, key) {\n          clone.set(key, handleCopy(value, cache));\n        });\n        return clone;\n      } // sets\n\n\n      if (realm.Set && object instanceof realm.Set) {\n        clone = new Constructor();\n        cache.set(object, clone);\n        object.forEach(function (value) {\n          clone.add(handleCopy(value, cache));\n        });\n        return clone;\n      } // blobs\n\n\n      if (realm.Blob && object instanceof realm.Blob) {\n        return object.slice(0, object.size, object.type);\n      } // buffers (node-only)\n\n\n      if (realm.Buffer && realm.Buffer.isBuffer(object)) {\n        clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(object.length) : new Constructor(object.length);\n        cache.set(object, clone);\n        object.copy(clone);\n        return clone;\n      } // arraybuffers / dataviews\n\n\n      if (realm.ArrayBuffer) {\n        // dataviews\n        if (realm.ArrayBuffer.isView(object)) {\n          clone = new Constructor(object.buffer.slice(0));\n          cache.set(object, clone);\n          return clone;\n        } // arraybuffers\n\n\n        if (object instanceof realm.ArrayBuffer) {\n          clone = object.slice(0);\n          cache.set(object, clone);\n          return clone;\n        }\n      } // if the object cannot / should not be cloned, don't\n\n\n      if ( // promise-like\n      typeof object.then === 'function' || // errors\n      object instanceof Error || // weakmaps\n      realm.WeakMap && object instanceof realm.WeakMap || // weaksets\n      realm.WeakSet && object instanceof realm.WeakSet) {\n        return object;\n      } // assume anything left is a custom constructor\n\n\n      return getObjectClone(object, realm, handleCopy, cache);\n    };\n\n    return handleCopy(object, createCache());\n  } // Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n  // expects there to be a default property on the exported object. See\n  // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\n\n\n  copy.default = copy;\n  /**\r\n   * @function strictCopy\r\n   *\r\n   * @description\r\n   * copy the object with `strict` option pre-applied\r\n   *\r\n   * @param object the object to copy\r\n   * @param [options] the options for copying with\r\n   * @param [options.realm] the realm (this) object the object is copied from\r\n   * @returns the copied object\r\n   */\n\n  copy.strict = function strictCopy(object, options) {\n    return copy(object, {\n      isStrict: true,\n      realm: options ? options.realm : void 0\n    });\n  };\n\n  return copy;\n});","map":{"version":3,"mappings":";;;;;EAAQ,IAAUA,gBAAgB,GAAKC,QAAQ,CAACC,SAAT,CAAkBC,QAAjD;EAEN,UAAM,GAMJC,MAAM,OANR;EAAA,IACAC,cAAc,GAKZD,MAAM,eANR;EAAA,IAEAE,wBAAwB,GAItBF,MAAM,yBANR;EAAA,IAGAG,mBAAmB,GAGjBH,MAAM,oBANR;EAAA,IAIAI,qBAAqB,GAEnBJ,MAAM,sBANR;EAAA,IAKAK,cAAc,GACZL,MAAM,eANR;EAOI,SAA2CA,MAAM,CAACF,SAAlD;EAAA,IAAEQ,cAAc,oBAAhB;EAAA,IAAkBC,oBAAoB,0BAAtC;EAEN;;;;;;;;;EAQO,IAAMC,QAAQ,GAAG;IACtBC,iBAAiB,EAAE,OAAOL,qBAAP,KAAiC,UAD9B;IAEtBM,OAAO,EAAE,OAAOC,OAAP,KAAmB;EAFN,CAAjB;EAKP;;;;;;;;;EAQO,IAAMC,WAAW,GAAG,SAAdA,WAAc;IACzB,IAAIJ,QAAQ,CAACE,OAAb,EAAsB;MACpB,OAAO,IAAIC,OAAJ,EAAP;IACD,CAHwB;;;IAMzB,IAAME,MAAM,GAAGC,MAAM,CAAC;MACpBC,GAAG,EAAE,aAACC,GAAD,EAAS;QAAK,QAAC,CAAC,CAACH,MAAM,CAACI,KAAP,CAAaC,OAAb,CAAqBF,GAArB,CAAH;MAA4B,CAD3B;MAEpBG,GAAG,EAAE,aAACH,GAAD,EAAWI,KAAX,EAAqB;QACxBP,MAAM,CAACI,KAAP,CAAaI,IAAb,CAAkBL,GAAlB;;QACAH,MAAM,CAACS,OAAP,CAAeD,IAAf,CAAoBD,KAApB;MACD,CALmB;MAMpBG,GAAG,EAAE,aAACP,GAAD,EAAS;QAAK,aAAM,CAACM,OAAP,CAAeT,MAAM,CAACI,KAAP,CAAaC,OAAb,CAAqBF,GAArB,CAAf;MAAyC;IANxC,CAAD,CAArB;IASAH,MAAM,CAACI,KAAP,GAAe,EAAf;IACAJ,MAAM,CAACS,OAAP,GAAiB,EAAjB;IAEA,OAAOT,MAAP;EACD,CAnBM;EAqBP;;;;;;;;;;;;EAUO,IAAMW,aAAa,GAAG,SAAhBA,aAAgB,CAACX,MAAD,EAAcY,KAAd,EAAmC;IAC9D,IAAI,CAACZ,MAAM,CAACa,WAAZ,EAAyB;MACvB,OAAOZ,MAAM,CAAC,IAAD,CAAb;IACD;;IAEO,IAAaa,WAAW,GAAKd,MAAM,YAAnC;IACR,IAAMf,SAAS,GAAGe,MAAM,CAACe,SAAP,IAAoBvB,cAAc,CAACQ,MAAD,CAApD;;IAEA,IAAIc,WAAW,KAAKF,KAAK,CAACzB,MAA1B,EAAkC;MAChC,OAAOF,SAAS,KAAK2B,KAAK,CAACzB,MAAN,CAAaF,SAA3B,GAAuC,EAAvC,GAA4CgB,MAAM,CAAChB,SAAD,CAAzD;IACD;;IAED,IAAI,CAACF,gBAAgB,CAACiC,IAAjB,CAAsBF,WAAtB,EAAmCT,OAAnC,CAA2C,eAA3C,CAAL,EAAkE;MAChE,IAAI;QACF,OAAO,IAAIS,WAAJ,EAAP;MACD,CAFD,CAEE,WAAM,CAAE;IACX;;IAED,OAAOb,MAAM,CAAChB,SAAD,CAAb;EACD,CAnBM;EAqBP;;;;;;;;;;;;;;EAYO,IAAMgC,mBAAmB,GAA0B,SAA7CA,mBAA6C,CACxDjB,MADwD,EAExDY,KAFwD,EAGxDM,UAHwD,EAIxDC,KAJwD,EAInC;IAErB,IAAMC,KAAK,GAAQT,aAAa,CAACX,MAAD,EAASY,KAAT,CAAhC,CAFqB;;IAIrBO,KAAK,CAACb,GAAN,CAAUN,MAAV,EAAkBoB,KAAlB;;IAEA,KAAK,IAAMjB,GAAX,IAAkBH,MAAlB,EAA0B;MACxB,IAAIP,cAAc,CAACuB,IAAf,CAAoBhB,MAApB,EAA4BG,GAA5B,CAAJ,EAAsC;QACpCiB,KAAK,CAACjB,GAAD,CAAL,GAAae,UAAU,CAAClB,MAAM,CAACG,GAAD,CAAP,EAAcgB,KAAd,CAAvB;MACD;IACF;;IAED,IAAIxB,QAAQ,CAACC,iBAAb,EAAgC;MAC9B,IAAMyB,OAAO,GAAa9B,qBAAqB,CAACS,MAAD,CAA/C;MAEQ,YAAM,GAAKqB,OAAO,OAAlB;;MAER,IAAIC,QAAJ,EAAY;QACV,KAAK,IAAIC,KAAK,GAAG,CAAZ,EAAeC,MAAM,SAA1B,EAA4BD,KAAK,GAAGD,QAApC,EAA4CC,KAAK,EAAjD,EAAqD;UACnDC,MAAM,GAAGH,OAAO,CAACE,KAAD,CAAhB;;UAEA,IAAI7B,oBAAoB,CAACsB,IAArB,CAA0BhB,MAA1B,EAAkCwB,MAAlC,CAAJ,EAA+C;YAC7CJ,KAAK,CAACI,MAAD,CAAL,GAAgBN,UAAU,CAAClB,MAAM,CAACwB,MAAD,CAAP,EAAiBL,KAAjB,CAA1B;UACD;QACF;MACF;IACF;;IAED,OAAOC,KAAP;EACD,CAjCM;EAmCP;;;;;;;;;;;;;;EAYO,IAAMK,oBAAoB,GAA0B,SAA9CA,oBAA8C,CACzDzB,MADyD,EAEzDY,KAFyD,EAGzDM,UAHyD,EAIzDC,KAJyD,EAIpC;IAErB,IAAMC,KAAK,GAAQT,aAAa,CAACX,MAAD,EAASY,KAAT,CAAhC,CAFqB;;IAIrBO,KAAK,CAACb,GAAN,CAAUN,MAAV,EAAkBoB,KAAlB;IAEA,IAAMM,UAAU,GAAwB/B,QAAQ,CAACC,iBAAT,GACpCN,mBAAmB,CAACU,MAAD,CAAnB,CAA4B2B,MAA5B,CAAoCpC,qBAAqB,CAACS,MAAD,CAAzD,CADoC,GAEpCV,mBAAmB,CAACU,MAAD,CAFvB;IAIQ,UAAM,GAAK0B,UAAU,OAArB;;IAER,IAAIE,MAAJ,EAAY;MACV,KAAK,IAAIL,KAAK,GAAG,CAAZ,EAAeM,QAAQ,SAAvB,EAAyBC,UAAU,SAAxC,EAA0CP,KAAK,GAAGK,MAAlD,EAA0DL,KAAK,EAA/D,EAAmE;QACjEM,QAAQ,GAAGH,UAAU,CAACH,KAAD,CAArB;;QAEA,IAAIM,QAAQ,KAAK,QAAb,IAAyBA,QAAQ,KAAK,QAA1C,EAAoD;UAClDC,UAAU,GAAGzC,wBAAwB,CAACW,MAAD,EAAS6B,QAAT,CAArC;;UAEA,IAAIC,UAAJ,EAAgB;;YAEd,IAAI,CAACA,UAAU,CAACpB,GAAZ,IAAmB,CAACoB,UAAU,CAACxB,GAAnC,EAAwC;cACtCwB,UAAU,CAACvB,KAAX,GAAmBW,UAAU,CAAClB,MAAM,CAAC6B,QAAD,CAAP,EAAmBV,KAAnB,CAA7B;YACD;;YAED,IAAI;cACF/B,cAAc,CAACgC,KAAD,EAAQS,QAAR,EAAkBC,UAAlB,CAAd;YACD,CAFD,CAEE,OAAOC,KAAP,EAAc;;cAEdX,KAAK,CAACS,QAAD,CAAL,GAAkBC,UAAU,CAACvB,KAA7B;YACD;UACF,CAZD,MAYO;;;YAGLa,KAAK,CAACS,QAAD,CAAL,GAAkBX,UAAU,CAAClB,MAAM,CAAC6B,QAAD,CAAP,EAAmBV,KAAnB,CAA5B;UACD;QACF;MACF;IACF;;IAED,OAAOC,KAAP;EACD,CA7CM;EA+CP;;;;;;;;;;;EASO,IAAMY,cAAc,GAAG,SAAjBA,cAAiB,CAACC,MAAD,EAAe;IAC3C,IAAIC,KAAK,GAAG,EAAZ;;IAEA,IAAID,MAAM,CAACE,MAAX,EAAmB;MACjBD,KAAK,IAAI,GAAT;IACD;;IAED,IAAID,MAAM,CAACG,UAAX,EAAuB;MACrBF,KAAK,IAAI,GAAT;IACD;;IAED,IAAID,MAAM,CAACI,SAAX,EAAsB;MACpBH,KAAK,IAAI,GAAT;IACD;;IAED,IAAID,MAAM,CAACK,OAAX,EAAoB;MAClBJ,KAAK,IAAI,GAAT;IACD;;IAED,IAAID,MAAM,CAACM,MAAX,EAAmB;MACjBL,KAAK,IAAI,GAAT;IACD;;IAED,OAAOA,KAAP;EACD,CAxBM,ECvMP;;;EAGQ,WAAO,GAAKM,KAAK,QAAjB;;EAER,IAAMC,WAAW,GAAI;IACnB,IAAI,OAAOC,IAAP,KAAgB,WAApB,EAAiC;MAC/B,OAAOA,IAAP;IACD;;IAED,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;MACjC,OAAOA,MAAP;IACD;;IAED,IAAI,OAAOR,MAAP,KAAkB,WAAtB,EAAmC;MACjC,OAAOA,MAAP;IACD;;IAED,IAAIS,OAAO,IAAIA,OAAO,CAACb,KAAvB,EAA8B;MAC5Ba,OAAO,CAACb,KAAR,CAAc,mDAAd;IACD;EACF,CAhBmB,EAApB;EAkBA;;;;;;;;;;;;;;;;;;;;;EAmBA,SAASc,IAAT,CAAiB7C,MAAjB,EAA4B8C,OAA5B,EAAsD;;IAEpD,IAAMC,QAAQ,GAAY,CAAC,EAAED,OAAO,IAAIA,OAAO,CAACC,QAArB,CAA3B;IACA,IAAMnC,KAAK,GAAoBkC,OAAO,IAAIA,OAAO,CAAClC,KAApB,IAA8B6B,WAA5D;IAEA,IAAMO,cAAc,GAA0BD,QAAQ,GAClDtB,oBADkD,GAElDR,mBAFJ;;;;;;;;;;;IAaA,IAAMC,UAAU,GAAoB,SAA9BA,UAA8B,CAAClB,MAAD,EAAcmB,KAAd,EAAmC;MACrE,IAAI,CAACnB,MAAD,IAAW,OAAOA,MAAP,KAAkB,QAAjC,EAA2C;QACzC,OAAOA,MAAP;MACD;;MAAC,IAAImB,KAAK,CAACjB,GAAN,CAAUF,MAAV,CAAJ,EAAuB;QACvB,OAAOmB,KAAK,CAACT,GAAN,CAAUV,MAAV,CAAP;MACD;;MAEO,IAAac,WAAW,GAAKd,MAAM,YAAnC,CAP6D;;MAUrE,IAAIc,WAAW,KAAKF,KAAK,CAACzB,MAA1B,EAAkC;QAChC,OAAO6D,cAAc,CAAChD,MAAD,EAASY,KAAT,EAAgBM,UAAhB,EAA4BC,KAA5B,CAArB;MACD;;MAED,IAAIC,KAAJ,CAdqE;;MAgBrE,IAAI6B,OAAO,CAACjD,MAAD,CAAX,EAAqB;;QAEnB,IAAI+C,QAAJ,EAAc;UACZ,OAAOtB,oBAAoB,CAACzB,MAAD,EAASY,KAAT,EAAgBM,UAAhB,EAA4BC,KAA5B,CAA3B;QACD;;QAEO,YAAM,GAAKnB,MAAM,OAAjB;QAERoB,KAAK,GAAG,IAAIN,WAAJ,EAAR;QACAK,KAAK,CAACb,GAAN,CAAUN,MAAV,EAAkBoB,KAAlB;;QAEA,KAAK,IAAIG,KAAK,GAAW,CAAzB,EAA4BA,KAAK,GAAGD,QAApC,EAA4CC,KAAK,EAAjD,EAAqD;UACnDH,KAAK,CAACG,KAAD,CAAL,GAAeL,UAAU,CAAClB,MAAM,CAACuB,KAAD,CAAP,EAAgBJ,KAAhB,CAAzB;QACD;;QAED,OAAOC,KAAP;MACD,CAhCoE;;;MAmCrE,IAAIpB,MAAM,YAAYY,KAAK,CAACsC,IAA5B,EAAkC;QAChC,OAAO,IAAIpC,WAAJ,CAAgBd,MAAM,CAACmD,OAAP,EAAhB,CAAP;MACD,CArCoE;;;MAwCrE,IAAInD,MAAM,YAAYY,KAAK,CAACwC,MAA5B,EAAoC;QAClChC,KAAK,GAAG,IAAIN,WAAJ,CAAgBd,MAAM,CAACqD,MAAvB,EAA+BrD,MAAM,CAACkC,KAAP,IAAgBF,cAAc,CAAChC,MAAD,CAA7D,CAAR;QAEAoB,KAAK,CAACkC,SAAN,GAAkBtD,MAAM,CAACsD,SAAzB;QAEA,OAAOlC,KAAP;MACD,CA9CoE;;;MAiDrE,IAAIR,KAAK,CAAC2C,GAAN,IAAavD,MAAM,YAAYY,KAAK,CAAC2C,GAAzC,EAA8C;QAC5CnC,KAAK,GAAG,IAAIN,WAAJ,EAAR;QACAK,KAAK,CAACb,GAAN,CAAUN,MAAV,EAAkBoB,KAAlB;QAEApB,MAAM,CAACwD,OAAP,CAAe,UAACjD,KAAD,EAAaJ,GAAb,EAAqB;UAClCiB,KAAK,CAACd,GAAN,CAAUH,GAAV,EAAee,UAAU,CAACX,KAAD,EAAQY,KAAR,CAAzB;QACD,CAFD;QAIA,OAAOC,KAAP;MACD,CA1DoE;;;MA6DrE,IAAIR,KAAK,CAAC6C,GAAN,IAAazD,MAAM,YAAYY,KAAK,CAAC6C,GAAzC,EAA8C;QAC5CrC,KAAK,GAAG,IAAIN,WAAJ,EAAR;QACAK,KAAK,CAACb,GAAN,CAAUN,MAAV,EAAkBoB,KAAlB;QAEApB,MAAM,CAACwD,OAAP,CAAe,UAACjD,KAAD,EAAW;UACxBa,KAAK,CAACsC,GAAN,CAAUxC,UAAU,CAACX,KAAD,EAAQY,KAAR,CAApB;QACD,CAFD;QAIA,OAAOC,KAAP;MACD,CAtEoE;;;MAyErE,IAAIR,KAAK,CAAC+C,IAAN,IAAc3D,MAAM,YAAYY,KAAK,CAAC+C,IAA1C,EAAgD;QAC9C,OAAO3D,MAAM,CAAC4D,KAAP,CAAa,CAAb,EAAgB5D,MAAM,CAAC6D,IAAvB,EAA6B7D,MAAM,CAAC8D,IAApC,CAAP;MACD,CA3EoE;;;MA8ErE,IAAIlD,KAAK,CAACmD,MAAN,IAAgBnD,KAAK,CAACmD,MAAN,CAAaC,QAAb,CAAsBhE,MAAtB,CAApB,EAAmD;QACjDoB,KAAK,GAAGR,KAAK,CAACmD,MAAN,CAAaE,WAAb,GACJrD,KAAK,CAACmD,MAAN,CAAaE,WAAb,CAAyBjE,MAAM,CAAC4B,MAAhC,CADI,GAEJ,IAAId,WAAJ,CAAgBd,MAAM,CAAC4B,MAAvB,CAFJ;QAIAT,KAAK,CAACb,GAAN,CAAUN,MAAV,EAAkBoB,KAAlB;QACApB,MAAM,CAAC6C,IAAP,CAAYzB,KAAZ;QAEA,OAAOA,KAAP;MACD,CAvFoE;;;MA0FrE,IAAIR,KAAK,CAACsD,WAAV,EAAuB;;QAErB,IAAItD,KAAK,CAACsD,WAAN,CAAkBC,MAAlB,CAAyBnE,MAAzB,CAAJ,EAAsC;UACpCoB,KAAK,GAAG,IAAIN,WAAJ,CAAgBd,MAAM,CAACoE,MAAP,CAAcR,KAAd,CAAoB,CAApB,CAAhB,CAAR;UACAzC,KAAK,CAACb,GAAN,CAAUN,MAAV,EAAkBoB,KAAlB;UACA,OAAOA,KAAP;QACD,CANoB;;;QASrB,IAAIpB,MAAM,YAAYY,KAAK,CAACsD,WAA5B,EAAyC;UACvC9C,KAAK,GAAGpB,MAAM,CAAC4D,KAAP,CAAa,CAAb,CAAR;UACAzC,KAAK,CAACb,GAAN,CAAUN,MAAV,EAAkBoB,KAAlB;UACA,OAAOA,KAAP;QACD;MACF,CAxGoE;;;MA2GrE;MAEE,OAAOpB,MAAM,CAACqE,IAAd,KAAuB,UAAvB;MAEArE,MAAM,YAAYsE,KAFlB;MAIC1D,KAAK,CAACd,OAAN,IAAiBE,MAAM,YAAYY,KAAK,CAACd,OAJ1C;MAMCc,KAAK,CAAC2D,OAAN,IAAiBvE,MAAM,YAAYY,KAAK,CAAC2D,OAR5C,EASE;QACA,OAAOvE,MAAP;MACD,CAtHoE;;;MAyHrE,OAAOgD,cAAc,CAAChD,MAAD,EAASY,KAAT,EAAgBM,UAAhB,EAA4BC,KAA5B,CAArB;IACD,CA1HD;;IA4HA,OAAOD,UAAU,CAAClB,MAAD,EAASD,WAAW,EAApB,CAAjB;EACD,EAED;EACA;EACA;;;EACA8C,IAAI,CAAC2B,OAAL,GAAe3B,IAAf;EAEA;;;;;;;;;;;;EAWAA,IAAI,CAAC4B,MAAL,GAAc,SAASC,UAAT,CAAoB1E,MAApB,EAAiC8C,OAAjC,EAA2D;IACvE,OAAOD,IAAI,CAAC7C,MAAD,EAAS;MAClB+C,QAAQ,EAAE,IADQ;MAElBnC,KAAK,EAAEkC,OAAO,GAAGA,OAAO,CAAClC,KAAX,GAAmB,KAAK;IAFpB,CAAT,CAAX;EAID,CALD","names":["toStringFunction","Function","prototype","toString","Object","defineProperty","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","getPrototypeOf","hasOwnProperty","propertyIsEnumerable","SUPPORTS","SYMBOL_PROPERTIES","WEAKMAP","WeakMap","createCache","object","create","has","key","_keys","indexOf","set","value","push","_values","get","getCleanClone","realm","constructor","Constructor","__proto__","call","getObjectCloneLoose","handleCopy","cache","clone","symbols","length_1","index","symbol","getObjectCloneStrict","properties","concat","length","property","descriptor","error","getRegExpFlags","regExp","flags","global","ignoreCase","multiline","unicode","sticky","Array","GLOBAL_THIS","self","window","console","copy","options","isStrict","getObjectClone","isArray","Date","getTime","RegExp","source","lastIndex","Map","forEach","Set","add","Blob","slice","size","type","Buffer","isBuffer","allocUnsafe","ArrayBuffer","isView","buffer","then","Error","WeakSet","default","strict","strictCopy"],"sources":["C:\\OTHERS\\Codes\\beach-resort-\\node_modules\\fast-copy\\src\\utils.ts","C:\\OTHERS\\Codes\\beach-resort-\\node_modules\\fast-copy\\src\\index.ts"],"sourcesContent":["const { toString: toStringFunction } = Function.prototype;\nconst {\n  create,\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n  getPrototypeOf,\n} = Object;\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\n/**\n * @enum\n *\n * @const {Object} SUPPORTS\n *\n * @property {boolean} SYMBOL_PROPERTIES are symbol properties supported\n * @property {boolean} WEAKMAP is WeakMap supported\n */\nexport const SUPPORTS = {\n  SYMBOL_PROPERTIES: typeof getOwnPropertySymbols === 'function',\n  WEAKMAP: typeof WeakMap === 'function',\n};\n\n/**\n * @function createCache\n *\n * @description\n * get a new cache object to prevent circular references\n *\n * @returns the new cache object\n */\nexport const createCache = (): FastCopy.Cache => {\n  if (SUPPORTS.WEAKMAP) {\n    return new WeakMap();\n  }\n\n  // tiny implementation of WeakMap\n  const object = create({\n    has: (key: any) => !!~object._keys.indexOf(key),\n    set: (key: any, value: any) => {\n      object._keys.push(key);\n      object._values.push(value);\n    },\n    get: (key: any) => object._values[object._keys.indexOf(key)],\n  });\n\n  object._keys = [];\n  object._values = [];\n\n  return object;\n};\n\n/**\n * @function getCleanClone\n *\n * @description\n * get an empty version of the object with the same prototype it has\n *\n * @param object the object to build a clean clone from\n * @param realm the realm the object resides in\n * @returns the empty cloned object\n */\nexport const getCleanClone = (object: any, realm: FastCopy.Realm): any => {\n  if (!object.constructor) {\n    return create(null);\n  }\n\n  const { constructor: Constructor } = object;\n  const prototype = object.__proto__ || getPrototypeOf(object);\n\n  if (Constructor === realm.Object) {\n    return prototype === realm.Object.prototype ? {} : create(prototype);\n  }\n\n  if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n    try {\n      return new Constructor();\n    } catch {}\n  }\n\n  return create(prototype);\n};\n\n/**\n * @function getObjectCloneLoose\n *\n * @description\n * get a copy of the object based on loose rules, meaning all enumerable keys\n * and symbols are copied, but property descriptors are not considered\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneLoose: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = handleCopy(object[key], cache);\n    }\n  }\n\n  if (SUPPORTS.SYMBOL_PROPERTIES) {\n    const symbols: symbol[] = getOwnPropertySymbols(object);\n\n    const { length } = symbols;\n\n    if (length) {\n      for (let index = 0, symbol; index < length; index++) {\n        symbol = symbols[index];\n\n        if (propertyIsEnumerable.call(object, symbol)) {\n          clone[symbol] = handleCopy(object[symbol], cache);\n        }\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getObjectCloneStrict\n *\n * @description\n * get a copy of the object based on strict rules, meaning all keys and symbols\n * are copied based on the original property descriptors\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneStrict: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  const properties: (string | symbol)[] = SUPPORTS.SYMBOL_PROPERTIES\n    ? getOwnPropertyNames(object).concat((getOwnPropertySymbols(object) as unknown) as string[])\n    : getOwnPropertyNames(object);\n\n  const { length } = properties;\n\n  if (length) {\n    for (let index = 0, property, descriptor; index < length; index++) {\n      property = properties[index];\n\n      if (property !== 'callee' && property !== 'caller') {\n        descriptor = getOwnPropertyDescriptor(object, property);\n\n        if (descriptor) {\n          // Only clone the value if actually a value, not a getter / setter.\n          if (!descriptor.get && !descriptor.set) {\n            descriptor.value = handleCopy(object[property], cache);\n          }\n\n          try {\n            defineProperty(clone, property, descriptor);\n          } catch (error) {\n            // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n            clone[property] = descriptor.value;\n          }\n        } else {\n          // In extra edge cases where the property descriptor cannot be retrived, fall back to\n          // the loose assignment.\n          clone[property] = handleCopy(object[property], cache);\n        }\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getRegExpFlags\n *\n * @description\n * get the flags to apply to the copied regexp\n *\n * @param regExp the regexp to get the flags of\n * @returns the flags for the regexp\n */\nexport const getRegExpFlags = (regExp: RegExp): string => {\n  let flags = '';\n\n  if (regExp.global) {\n    flags += 'g';\n  }\n\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n\n  return flags;\n};\n","// utils\nimport { createCache, getObjectCloneLoose, getObjectCloneStrict, getRegExpFlags } from './utils';\n\nconst { isArray } = Array;\n\nconst GLOBAL_THIS = (() => {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  if (console && console.error) {\n    console.error('Unable to locate global object, returning \"this\".');\n  }\n})();\n\n/**\n * @function copy\n *\n * @description\n * copy an object deeply as much as possible\n *\n * If `strict` is applied, then all properties (including non-enumerable ones)\n * are copied with their original property descriptors on both objects and arrays.\n *\n * The object is compared to the global constructors in the `realm` provided,\n * and the native constructor is always used to ensure that extensions of native\n * objects (allows in ES2015+) are maintained.\n *\n * @param object the object to copy\n * @param [options] the options for copying with\n * @param [options.isStrict] should the copy be strict\n * @param [options.realm] the realm (this) object the object is copied from\n * @returns the copied object\n */\nfunction copy<T>(object: T, options?: FastCopy.Options): T {\n  // manually coalesced instead of default parameters for performance\n  const isStrict: boolean = !!(options && options.isStrict);\n  const realm: FastCopy.Realm = (options && options.realm) || GLOBAL_THIS;\n\n  const getObjectClone: FastCopy.ObjectCloner = isStrict\n    ? getObjectCloneStrict\n    : getObjectCloneLoose;\n\n  /**\n   * @function handleCopy\n   *\n   * @description\n   * copy the object recursively based on its type\n   *\n   * @param object the object to copy\n   * @returns the copied object\n   */\n  const handleCopy: FastCopy.Copier = (object: any, cache: FastCopy.Cache): any => {\n    if (!object || typeof object !== 'object') {\n      return object;\n    } if (cache.has(object)) {\n      return cache.get(object);\n    }\n\n    const { constructor: Constructor } = object;\n\n    // plain objects\n    if (Constructor === realm.Object) {\n      return getObjectClone(object, realm, handleCopy, cache);\n    }\n\n    let clone: any;\n    // arrays\n    if (isArray(object)) {\n      // if strict, include non-standard properties\n      if (isStrict) {\n        return getObjectCloneStrict(object, realm, handleCopy, cache);\n      }\n\n      const { length } = object;\n\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      for (let index: number = 0; index < length; index++) {\n        clone[index] = handleCopy(object[index], cache);\n      }\n\n      return clone;\n    }\n\n    // dates\n    if (object instanceof realm.Date) {\n      return new Constructor(object.getTime());\n    }\n\n    // regexps\n    if (object instanceof realm.RegExp) {\n      clone = new Constructor(object.source, object.flags || getRegExpFlags(object));\n\n      clone.lastIndex = object.lastIndex;\n\n      return clone;\n    }\n\n    // maps\n    if (realm.Map && object instanceof realm.Map) {\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      object.forEach((value: any, key: any) => {\n        clone.set(key, handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // sets\n    if (realm.Set && object instanceof realm.Set) {\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      object.forEach((value: any) => {\n        clone.add(handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // blobs\n    if (realm.Blob && object instanceof realm.Blob) {\n      return object.slice(0, object.size, object.type);\n    }\n\n    // buffers (node-only)\n    if (realm.Buffer && realm.Buffer.isBuffer(object)) {\n      clone = realm.Buffer.allocUnsafe\n        ? realm.Buffer.allocUnsafe(object.length)\n        : new Constructor(object.length);\n\n      cache.set(object, clone);\n      object.copy(clone);\n\n      return clone;\n    }\n\n    // arraybuffers / dataviews\n    if (realm.ArrayBuffer) {\n      // dataviews\n      if (realm.ArrayBuffer.isView(object)) {\n        clone = new Constructor(object.buffer.slice(0));\n        cache.set(object, clone);\n        return clone;\n      }\n\n      // arraybuffers\n      if (object instanceof realm.ArrayBuffer) {\n        clone = object.slice(0);\n        cache.set(object, clone);\n        return clone;\n      }\n    }\n\n    // if the object cannot / should not be cloned, don't\n    if (\n      // promise-like\n      typeof object.then === 'function' ||\n      // errors\n      object instanceof Error ||\n      // weakmaps\n      (realm.WeakMap && object instanceof realm.WeakMap) ||\n      // weaksets\n      (realm.WeakSet && object instanceof realm.WeakSet)\n    ) {\n      return object;\n    }\n\n    // assume anything left is a custom constructor\n    return getObjectClone(object, realm, handleCopy, cache);\n  };\n\n  return handleCopy(object, createCache());\n}\n\n// Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n// expects there to be a default property on the exported object. See\n// [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\ncopy.default = copy;\n\n/**\n * @function strictCopy\n *\n * @description\n * copy the object with `strict` option pre-applied\n *\n * @param object the object to copy\n * @param [options] the options for copying with\n * @param [options.realm] the realm (this) object the object is copied from\n * @returns the copied object\n */\ncopy.strict = function strictCopy(object: any, options?: FastCopy.Options) {\n  return copy(object, {\n    isStrict: true,\n    realm: options ? options.realm : void 0,\n  });\n};\n\nexport default copy;\n"]},"metadata":{},"sourceType":"script"}